1)Когда слишком много производных классов верхние классы иерархии удобнее сделать абстрактными с помощью ключевого слова abstract. 
Если в классе есть хотя бы один абстрактный метод, то этот класс должен быть абстрактным. Мы не можем создавать объект абстрактного класса, однако можем от него наследоваться, а у наследников уже могут быть объекты.
Интерфейс. Поля у интерфейса по умолчанию  final static. Все методы по умолчанию открыты (public). У интерфейса могут быть не определены тела методов. Интерфейс реализуется, а абстрактный класс наследуется, то реализовать можем много раз, а наследовать только 1 класс.
Для реализации интерфейса необходимо реализовать все его методы.

2)в Java нет ручного управления памятью, этот процесс происходит автоматически.
Сборщик мусора -- процесс освобождения памяти от мусора, удаляются те объекты, на которых больше ничего не ссылается.
Для того, чтобы вызвать сборщик мусора, нужно вызвать метод System.runFinalization(), который в свою очередь приведет к вызову метода finalize(). Который показывает какие действия нужно выполнить непосредственно перед уничтожением объекта сборщиком мусора.

3)Допустим у нас есть суперкласс и класс, производный от него. Если переменной суперкласса присваивается объект подкласса, то компилятор позволяет это сделать. Если наоборот, то необходимо явное приведение типа. Так как если переменной суперкласса присваивается объект подклассса, то возможности сужаются, и это можно сделать, однако при обратной ситуации (объект суперкласса присвается переменной производнного класса), то возможности расширяются, и компилятор не позволит этого сделать, если не применить приведение классов (явно, указав в скобках имя подкласса).

4)Конструктор используется для создания объекта. По синтаксису конструктор похож на метод, только он ничего не возвращает. Также имя конструктора совпадает с именем класса.
Конструктор можно перегружать (то есть делать конструктор с одним и тем же именем, но разными  параметрами).

5)Да, можно, при помощи ключевого слова this.

Если мы имеем дело с перегруженными конструкторами, то можно один конструктор вызывать из другого через ключевое слово this.  Вызов конструктора this() должен быть первым оператором в конструкторе. При выполнении this() сначала выполняется перегруженный конструктор, который соответствует списку параметров. Затем выполняются операторы, находящиеся внутри исходного конструктора, если таковые существуют.

6)JDK -- Средство разработчика Java, включающие в себя набор утилит, стандартные библиотеки с их кодом и набор демонстрационных примеров.

JRE -- Среда выполнения, предназначенная только для запуска готовых приложений, поэтому содержит только реализацию виртуальной машины и набор стандартны библиотек. JRE
выполняет код, откомпилированный для JVM.

То есть JDK нужна для разработки, а  JRE для пользования.

7)В JAva есть 2 типа исключений -- проверяемые и непроверяемые. IOExceptipon относится к проверяемым исключениям. Провеяемые исключения должны обрабатываться (блок catch), а не проверяемые нет.
FileNotFoundException наследуется от IOExceptipon, следовательно мы должны перехватывать сначала FileNotFoundException, потом IOExceptipon.

8)Если мы определяем один класс внутри другого, то такие классы называются вложенными.
 Внутренний класс -- это нестатический вложенный класс. Внутренний класс имеет доступ ко всем переменным и методам своего внешнего класса и может непосредственно ссылаться на них. 
 
Если связь между объектом внутреннего класса и объектом внешнего класса не нужна, можно сделать внутренний класс статическим (static). Такой класс называют вложенным (nested).

Вложенный класс имеет доступ к членам своего внешнего класса, в том числе и к закрытым членам. Однако, внешний класс не имеет доступа к членам вложенного класса. Вложенный класс при этом является членом внешнего класса.

9)С помощью ключевого слова super.

10)Очередь -- осуществляет принцип --  первым обслуживается тот, кто первым пришел.

Стек -- осуществляет принцип -- первым обслуживается тот, кто зашел послденим.

11)Что-то связанное со сборкой мусора и созданием новых объектов в Java.
В (young generation) происходит создание новых объектов.

12)Шаблон Creator.

Шаблон -- частоиспользуемый принцип ООП.

13) В Java есть различные модификаторы доступа класса: Public(доступен всем), protected(доступен
классам или типам, которые являются производными от содержащего класса), private(никому не доступен), friendly(доступ в пределах пакета).
Следовательно, надо использовать friendly, он же стоит по умолчанияю.

14)Внутренние классы -- это нестатические вложенные классы.

15)Нельзя.
Статический метод -- метод, к которому можно обратиться, не создавая объекта класса.
Статический метод не может обратиться к нестатическим полям класса, так как они принадлежат объекту, а статистический метод классу.
16)byte (1 байт), short (2 байта), int (4 байта), long (8 байт), float (4 байта), double (8 байта), char (2 байта), boolean .

17)Переопределение -- объявление метода в производном классе (extends), причем сигнатура этого метода совпадает с сигнатурой, описанной в суперклассе (классе, от которого наследуем).Статические методы не переопределяются нестатическими, нестатические методы не переопределяются
статическими.  (когда мы переопределяем метод при наследовании).
Перегрузка -- определение методов с одинаковыми названиями, но разными параметрами. При этом статические методы могут перегружаться нестатическими и наоборот. (несколько методов, которые одинаково называются, но имеют разные параметры)

18)Итератор -- интерфейс для удобства работы с коллекциями. Итератор можно использовать для перебора элементов коллекции.

19)Типы исключений -- это Error, Exception, RuntimeException. Исключительные ситуации типа
Exception всегда проверяемые, исключительные ситуации типа RuntimeException -
непроверяемые исключения. Проверяемые исключения должны быть обработаны.

20)throw -- используется для выброса исключения вручную, размещается внутри метода.

throws -- в заголовке объявления метода, для обработки исключения, которое выброшено из метода.

21)Блок finally выполняется всегда, даже когда выбрасывается исключение. Это нужно для того, чтобы несмотря на исключение (из-за которого мы можем раньше времени выйти из метода, или неправильно пройти его) мы выполнили какой-то блок программы.

22)finalize -- метод, который вызывается непосредственно перед тем, как сборщик мусора уничтожит объект, причем этот метод определяет конкретные действия, которые нужно сделать перед уничтожением. Его нежелательно использовать, так как мы не можем предсказать результат его работы.

23)Внутренние классы в Java делятся на три вида: внутренние классы , локальные классы, анонимные классы.
Внутренние классы -- объявленные классы внутри классов.
Локальные классы --  на практике чаще всего используются внутри метода другого класса.
Анонимные классы -- локальные классы без имени.
